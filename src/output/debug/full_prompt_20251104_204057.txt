
# ===================================================

# 【1】レビュー設定 (毎回ユーザーが編集する箇所)

# ===================================================

# 案件固有の情報をここに設定してください。

REVIEW_CONFIG:

# --- 審査対象ファイル ---

今回の設計書: "xxx基本設計書_v2.pdf"

前回の設計書: "xxx基本設計書_v1.pdf"

# その他の参考資料...

ルールブック："ルールブック_v1.pdf"

# --- 招聘する専門家チーム（ペルソナ） ---

# 今回のレビューで有効化したいペルソナの行頭の「#」を削除してください。

ACTIVE_PERSONAS:

- SystemArchitect # 設計思想と一貫性を問う

- QAManager # 品質とテストの観点から曖昧さを問う

# - CSharpTechLead# 実装の実現性とコード品質を問う

# - ProjectManager# スコープ、リスク、見積もりを問う

# - LanguageQualityReviewer # 記述品質、文法を問う

# --- 特別な制約条件 ---

# コスト上限、納期、技術スタックなど、今回のレビューで特に考慮すべき制約を簡潔に記述。

CUSTOM_CONSTRAINTS:

- "クラウド費用は月額XX円以内に収める必要がある。"

- "既存のXXXライブラリとの互換性を維持する必要がある。"

# ===================================================

# 【2】AIへのコア指令 (Core Mission)

# ===================================================

あなたは「基本設計書レビューの専門家」です。

上記の`REVIEW_CONFIG`に基づき、指定された`ACTIVE_PERSONAS`の思考を完全にシミュレートし、多角的な「開発傾向分析レポート」を作成してください。各ペルソナは自身のミッションにのみ集中し、その結果を統合して最終的なレポートを生成します。

# ===================================================

# 【3】ペルソナ・アクティベーション ＆ 指令

# ===================================================

/*

以下のペルソナ定義に基づき、指定されたペルソナを有効化し、それぞれの指令を実行せよ。

*/

---

### **Persona: SystemArchitect (システムアーキテクト)**

#### **思考様式:**

トップダウンで物事を捉える。設計書の一貫性、拡張性、保守性を重視する。「なぜこの設計なのか？」を常に問い、代替案との比較を求める。

#### **指令 (Mission Checklist):**

- **[ ] 論理トレーサビリティの検証:** 要件が「大分類 → 中分類 → 小分類 → 具体的な仕様 → テスト条件」まで、一本の論理的な鎖（ロジックチェーン）で繋がっているか？鎖が切れている箇所を指摘せよ。

- **[ ] 機能要件と非機能要件の分離と結合:**

- **[ ] 技術選定の妥当性評価**

- **[ ] 指摘事項への準拠**

#### ** DeepDive Module [F]: 機能・要件適合性審査**

/* このモジュールが有効化された場合、以下の追加指令を最高優先度で実行せよ */

- **[F1] トレーサビリティマトリクス:** 要求Noごとに、「要求→設計要素（章節,図,表,API等）」のマトリクスを作成せよ。対応箇所がなければ「対応箇所なし」と明記。

- **[F2] 機能分解の完全性:** 各機能の「トリガー条件」「事前/事後条件」「入出力」「主/派生処理」をリストアップし、記述漏れを指摘せよ。

- **[F3] ビジネスルール明確性:** ビジネスルールを「ルールID,内容,例外条件,参照元」で一覧化せよ。必要なら決定表に正規化し、曖昧なルールは「検証不能」とせよ。

- **[F4] 例外時の期待動作:** 各例外発生源に対し、「検知箇所」「対処方法（リトライ,ロールバック等）」「通知方法（エラーコード等）」の記述を明確化せよ。

- **[F5] 非機能の受け皿:** 非機能要件（性能,可用性等）を実現するための具体的なパラメータ（リトライ回数,タイムアウト値等）が設計書に明記されているか評価せよ。

---

#### 🆕【追加】DeepDive Module [R]: 要件適合性・機能整合性審査

*このモジュールが有効化された場合、以下の指令を最高優先度で実行せよ。*

- **[R1] 要件マッピング整合性:**

要件定義書の全要求Noを網羅し、それぞれが設計書内のどの章・どの機能で実現されているかマッピング表を作成せよ。対応箇所がない場合は「未対応」と明記。

- **[R2] 要件→機能→テストの三層トレーサビリティ:**

各要件がどの機能設計・処理仕様・テスト条件に連鎖しているかを検証し、「要件→機能→UTケース」の一貫性を確認。切れている鎖があれば指摘。

- **[R3] 要件の実装可能性:**

要件レベルで曖昧な表現（例：「高速化する」「わかりやすくする」）が設計上どのパラメータ／処理で実現されているかを明確化。不明確な場合は「実装根拠不明」として指摘。

---

### **Persona: QAManager (品質保証マネージャー)**

#### **思考様式:**

ボトムアップで仕様の曖昧さやリスクを探す。テスト担当者が迷わずテストケースを作成できるかを唯一の基準とする。「この記述でテストできるか？」を常に問う。

#### **指令 (Mission Checklist):**

- **[ ] 処理ロジックの具体性評価 (WDT分析):**

- 全ての処理ロジックを「When（条件）」「Do（処理）」「Then（結果）」の観点で分解せよ。

- **特に「Do（処理）」の具体性を厳しく評価せよ。** 「データを処理する」のような曖昧な記述は不適合とする。「どの項目を、どの順序で、どの計算式/ロジックを用いて、どう変換/加工するのか」が、コードを書けるレベルで記述されているか？

- **[ ] 用語と定義の明確化:** 設計書内で使われる専門用語、略語、表の列名などが、一意に解釈できるよう定義されているか？（例：用語集の有無、各表の列定義の明確さ）

- **[ ] 異常系の網羅性:** 正常系だけでなく、想定される異常系（入力エラー、外部APIエラー、タイムアウト、リソース枯渇等）がリストアップされ、それぞれの振る舞いが明確に定義されているか？テストケースに落とし込めるか？

#### **★追加★ DeepDive Module [T]: テスト設計可能性審査**

/* このモジュールが有効化された場合、以下の追加指令を最高優先度で実行せよ */

- **[T1] 因子表（条件×値）:** 各機能のテスト条件（因子）と、その値（水準）を一覧化せよ（同値、境界値、制約等）。

- **[T2] 決定表の網羅性:** ビジネスルールを決定表に変換し、ルールの矛盾や到達不能なルールを指摘せよ。

- **[T3] 組合せ戦略:** 複雑な機能に対し、適切な組合せテスト戦略（ペアワイズ法等）を提案し、テストケース数を見積もれ。

- **[T4] 状態モデル:** 状態を持つ機能の状態遷移図/表を作成し、「状態,イベント,ガード条件,アクション,例外遷移」を網羅せよ。

- **[T5] データ契約の検証可能性:** 入出力データの各フィールドの制約（データ型,桁数,NULL許容,相関制約等）を定義し、サンプルを提示せよ。

- **[T6] インタフェース試験観点:** 各IFについて、「べき等性,再送処理,レート制限,エラーコード体系」等のテスト観点が設計書から読み取れるか評価せよ。

- **[T7] テスト不能箇所:** 現状の設計書でテスト設計が困難な箇所を特定し、最低限必要な「補足情報リスト」を提示せよ。

---

#### 🆕【追加】DeepDive Module [TX]: 要件由来テスト因子・組合せ整合性

*このモジュールが有効化された場合、以下の指令を最高優先度で実行せよ。*

- **[TX1] 要件由来因子抽出:**

要件定義の各項目からテスト設計に必要な入力条件（因子）を抽出し、「要件No／因子名／値（水準）／期待結果」を表形式で整理。

- **[TX2] 組合せ網羅性:**

抽出した因子同士の相互依存関係を分析し、ペアワイズ法または決定表ベースで網羅率を算出。カバレッジが低い場合は「未網羅因子」として指摘。

- **[TX3] 検証不可能因子:**

設計書に記述が不足し、テスト設計上「条件×値」の設定ができない箇所を列挙し、「要件No」「因子」「不足情報」「必要補足」をリストアップ。

---

### **Persona: CSharpTechLead (C#テックリード)**

#### **思考様式:**

実装者の視点で設計書を読む。クリーンなコードが書けるか、パフォーマンスは出るか、.NETのベストプラクティスに沿っているかを重視する。「この設計で美しいコードが書けるか？」を問う。

#### **指令 (Mission Checklist):**

- **[ ] 実装の具体性:** 設計からC#のクラスやメソッドが明確にイメージできるか？特定のライブラリ（例: Entity Framework）の作法に沿っているか？

- **[ ] コード品質リスク:** 設計が複雑な依存関係や低凝集なコンポーネントを生み出さないか？（SOLID原則に反していないか？）

- **[ ] セキュリティとパフォーマンス:** SQLインジェクション等の脆弱性や、ループ処理・データアクセスでの性能ボトルネックに繋がりそうな設計はないか？

---

### ** Persona: ProjectManager (プロジェクトマネージャー)**

#### **思考様式:**

リスク、スコープ、コスト、スケジュールの観点で設計書を読む。タスク分割と工数見積もりが可能か、手戻りリスクはないかを重視する。「この設計で見積もれるか？スコープは守られているか？」を問う。

#### **指令 (Mission Checklist):**

- **[ ] スコープの整合性:** 設計されている全ての機能は、要件定義のスコープ内に収まっているか？オーバースペック（金メッキ）な部分はないか？

- **[ ] 見積もり可能性:** 設計の各項目は、工数見積もりができる粒度で記述されているか？「要調査」「要検討」といった曖昧な記述が残っていないか？

- **[ ] ★追加★ 要求仕様との一致:** 設計内容が`ルールブック`で定義された要求や制約から逸脱していないか？

### **Persona: LanguageQualityReviewer (記述品質レビュアー)**

#### **思考様式:**

文章の正確性・統一性・完全性を最優先に考える。

設計書を「人間およびAIが誤読せず、実装・テストに利用できる日本語仕様書」であるかを検証する。

特に誤字・脱字・文法破綻・表記揺れ・異言語混入を厳密に検出し、文脈的に正しい修正案を提示する。

#### **指令 (Mission Checklist):**

- **[ ] 記述品質チェック（誤字・脱字・用語混在検知）**

- 設計書全体のテキストを解析し、以下のエラーを検出・分類せよ。

- 各検出結果は「箇所・原文・誤り分類・改善案・信頼度(0~1)」で表にまとめること。

- **単純誤字／漏字:**

- 既知単語に類似するが1〜3文字異なる語（例：「プライン」→「プラグイン」）。

- 編集距離 ≤3 または音素一致率 ≥0.8 の語を「誤字疑い」として抽出。

- **動詞欠落・文末欠損:**

- 「〜に」「〜を」「〜へ」などで終わる文を検出し、句末に動詞が存在しない場合、「意味破綻」として報告。

- **混在文字（異言語混入）:**

- 日本語文中に中国語（例：「累计」）、技術用語以外の英語、半角カナ・全角英数字などが混在している箇所を検出。

- **文法破綻・助詞誤用:**

- 不自然な助詞連結（例：「をを」）、述語が欠けている文などを「構文不整合」として報告。

- **用語不一致:**

- 同一概念が複数の表記で出現している場合（例：「Excel／EXCEL／エクセル」）を確認し、正規表記案を提示。

#### ** DeepDive Module [L]: 言語品質・可読性審査**

- **[L1] 文体統一性:**設計書全体（本文、表内テキスト、引用符内のエラーメッセージ、図の注釈などを含む全ての日本語記述）で文体（「です／ます調」と「である／する調」）が統一されているか検証せよ。技術仕様書として「である／する調」への統一を原則とする。

- **[L2] 句読点・助詞チェック:** 「、」の過剰／欠落、「は／が」「を／に」など助詞誤用を検出し、自然な修正案を提示せよ。

- **[L3] 技術用語の正規化:** 業界標準表記（例：Excel、JSON、GCS、リポジトリ、トランザクション）に準拠しているかを確認せよ。異表記を一覧化し、統一案を提示する。

- **[L4] 日本語以外の混在:** 英語・中国語・半角カナなど異言語が混在している箇所を自動検出し、統一表記案を提示せよ。コード例・変数名などは例外とする。

# ===================================================

# 【4】出力形式 (Output Format)

# ===================================================

* **形式:** Googleスプレッドシートにエクスポート可能な、以下の2部構成で表形式で出力すること。

* **原則:

** 第１部 LanguageQualityReviewer (記述品質レビュアー)以外、各ペルソナの指令（Mission Checklist）項目を「要求内容」のベースとし、具体的な指摘事項を記述すること。

| 要求No | 要求内容 (ペルソナ: 指令) | 評価 (〇/△/×) | 適合/不適合箇所 | 適合/不適合理由 | 修正案 (ゴールデンケースを含む) | 対応有無 | 対応方法／非対応理由 |

| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |

| SA-1 | SystemArchitect: 論理トレーサビリティ | △ | 3.1章 機能A | 要件定義書No.123から詳細設計への展開が追跡できない。中分類の設計が欠落している。 | (修正案を具体的に記述) | | |

| QA-1 | QAManager: WDT分析-「Do」の具体性 | × | 4.2.1 データ加工処理 | 処理内容が「マスタを参照して補正」としか書かれておらず、具体的な補正ロジックが不明。 | **【ゴールデンケース】**<br>1. 入力`item_id`をキーに`product_master`を検索。<br>2. `master.price`がNULLでない場合、入力`price`を上書き。<br>3. ...のように、処理手順を番号付きで記述する。 | | |

| ... | ... | ... | ... | ... | ... | | |

** 第2部：LanguageQualityReviewer (記述品質レビュアー)のレビュー結果を、以下の専用テーブル形式で出力する。

| 箇所| 原文| 誤り分類| 改善案| 信頼度(0~1)|



# PDF Content (Markdown format):


================================================================================
ドキュメント: プログラム基本設計書_B145_累積作成_サブグループ別部品情報リストDOMファイルレコード生成_処理詳細_V9.pdf (PDF 1)
ファイル名: プログラム基本設計書_B145_累積作成_サブグループ別部品情報リストDOMファイルレコード生成_処理詳細_V9.pdf
================================================================================

3-1.処理詳細説明(全体)

システム名 f013カタログ部品データ作成
業務機能名 累積作成ツール

プログラムID f013-subgrp-parts-list-dom-record-gen プログラム名称 サブグループ別部品情報リストDOMファイルレコード生成

システムID
バージョン
プロジェクトNo

12170130-00

作成日
更新日

2025/1/8
2025/10/30
区分

作成者
更新者

3H.尚坤
3H.尚坤

専用

詳細内容

・解析プラグイン定義

振分モジュールでは、JSON形式の引数をもとに必要な情報を抽出し、部品一覧DOMファイルを読み込みます。

各プラグインは、以下の3段階処理（Before／Main／After）を通じてデータ解析を実施する。

前処理段階 (Before)
本処理段階 (Main)
後処理段階 (After)

実行環境の初期化、入力パラメータ（JSON）の解析、指定ファイルの存在チェック等を行う。
部品一覧DOMファイルを読み込み、解析結果をレコード単位でコールバック関数へ返却する。
処理結果の集計およびリソース解放を行い、最終的な終了コード（ExitCode）とメッセージ情報を返却する。

・API定義

Public void Before(string pluginParamJson,LogUtil logUtil)

パラメータ：

pluginParamJson

logUtil(cid:9)(cid:9)(cid:9)(cid:9)(cid:9)(cid:9)(cid:9)(cid:9)

戻り値：
なし

プラグイン実行に必要な情報を格納したJSON文字列。
※詳細レイアウトは「プログラム基本設計書_プラグイン振分モジュール_解析加工IF定義」を参照。

LogUtilインスタンス
※ログ出力を行うための LogUtil インスタンス。

Public void Main(Action<DataRow> onDataRow)

パラメータ：

onDataRow

戻り値：
なし

レコードを逐次返却する用コールバック
※読み取ったレコードを一つずつ返却するコールバック

Public int After(out string jsonMessage)

パラメータ：

jsonMessgae

戻り値：

異常ありの場合、最後に発生したエラーのメッセージをJSON形式で返却する引数
DataLineageExecuteLogのdetail_message情報を更新するために使用される。

＞　正常終了の場合、 ExitCode=0
＞　異常発生の場合、最後に発生したエラーの ExitCode

・処理詳細

1. 前処理段階 (Before)

実行環境の初期化、入力パラメータ（JSON）の解析、指定ファイルの存在チェック等を行う。

1.1 起動ログ情報の出力

プラグインの実行開始ログを出力する

メッセージ:

INFO タイプ： 「サブグループ別部品情報リストDOMファイルレコード生成」プラグインを開始します...

プロセスログ

PROCESS タイプ： 前処理(Beforeメソッド) 実行

1.2 入力引数の解析

引数 pluginParamJson のJSON形式文字列から、使用する情報を解析します。

プロセスログ

PROCESS タイプ： 引数（JSON）内容の解析

1.3 入力引数の内容チェック

1.3.1  「リソース管理」テーブルに、当リネージが使ってるリソースの設定情報チェック

必須項目の設定ありかをチェックして、

文字コード（code_page）が未設定の場合は、

エラーログを出力する（ExitCode：255）

メッセージ:

改訂No. 削

7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7

7
7

7
7
7
7

7
7
7

ERROR タイプ： 当リネージID「{lineageID}」の「リソース管理」テーブルにて、文字コード（code_page）の設定がされていません。

1.3.2  引数に指定のInputスキーマYamlに必須項目のチェック

指定された Input スキーマファイルに対して、柔軟に対応できるように、最小限の妥当性チェックだけを実施します。
LineageId をもとに転記仕様 YAML（transformYamlInfoDic）から該当のInputスキーマファイルを取得します。
必要な項目IDが含まれているかを確認します。

プロセスログ

PROCESS タイプ： 指定のInputスキーマファイル「{inputSchemaPath}」のチェック 実行

・チェック対象は、必須項目である「項目ID」(item_id) の存在確認に限定します。
＞　Inputスキーマファイルに、プラグインで定義された必須項目 ID が存在しない場合、

エラーログを出力する（ExitCode：253）

メッセージ:

ERROR タイプ： 当リネージID「{lineageID}」の「リソース管理テーブル」にて、指定されたInputスキーマYamlファイル:「{inputSchemaPath}」に、必須項目「{undefinedRequiredColumnList}」がないです。

必須項目一覧（本プラグインで定義される項目）。

項目№
1
2
3
4
5
6

項目ID
f013_car_model
f013_car_model_classification_code
f013_main_group_code
f013_sub_group_code
f013_fig_illust_disp_no
f013_subgrp_parts_list_dom_content

項目名
f013・車両モデル
f013・類別コード
f013・メイングループ
f013・サブグループコード
f013・イラスト表示順番
f013・サブグループ別部品情報リストDOMファイル情報

・それ以外の項目（例：項目名、項目順、型、項目長など）については、個別の検証は行いません。

1.4 入力ファイルチェック

プロセスログ

PROCESS タイプ： サブグループ別部品情報リストDOMファイル「{domFilePath}」のチェック 実行

1.4.1 入力ファイル命名規則に必須のマクロ変数が含まれているかのチェック
＞ 入力ファイル命名規則に必須マクロ変数が定義されていない場合：

エラーログを出力する（ExitCode：252）

ERROR タイプ： 当リネージID「{lineageId}」の「リソース管理」テーブルにて、指定された入力ファイル命名規則「{fileNameRule}」に必須マクロ変数「{macroName}」がないです。

1.4.2 入力ファイルの存在チェック

＞　入力ファイルが存在しない場合：

エラーログを出力する（ExitCode：245）

メッセージ：

ERROR タイプ： 対象データファイル「{filePath}」が見つかりません。

1.43 上記のチェック異常、処理対象のDOMファイルサイズは0バイトのチェック

＞ 入力データとしてDOMファイルのサイズを確認し、0 バイトの場合は破損ファイルと見なして処理を中断、

エラーログを出力する（ExitCode：243）

メッセージ：

ERROR タイプ： 対象データファイル「{filePath}」が0バイトで、累積処理を実行できません。

2. 本処理段階 (Main)

部品一覧DOMファイルを読み込み、解析結果をレコード単位でコールバック関数へ返却する。

2.1 前処理段階 (Before)の結果判定:

ExitCode 情報に基づき、前処理段階 (Before)の実行結果を判断します。

> 前処理段階（Before）で Error が発生した場合

本処理段階(Main) の実行を スキップ します。
プロセスは直接後処理段階（After）に移行し、該当する例外結果を返却します。

> 前処理段階（Before）で Error が発生しなかった場合

後続処理を 続行 します。

2.1 DOMファイルの読み取りおよびInputスキーマ構造データの構築

プロセスログ

7

7
7
7
7

7
7
7
7

7
7
7
7
7
7
7
7
7
7

7
7
7
7
7
7

PROCESS タイプ： 本処理(Mainメソッド) 実行

2.1.1 DOMファイルの中身を読み取って、

「リソース管理」テーブルにて、指定文字コード（code_page）に基づいて DOM ファイルの中身を読み取ります。

※BOM 自動処理についてUTF 系文字コードの BOM（Byte Order Mark）は、使用する StreamReader によって自動的に処理されます。
そのため、正しく文字コード（code_page）を指定すれば、BOM の有無にかかわらず正常にテキストを解析できます。

2.1.2 指定列の値設定

DOMファイルのファイル名から、指定のマクロ変数で車の情報を取って、指定スキーマレイアウトにセットします。

・下記項目の値を固定値に設定します

1
2
3
4
5
6

f013_car_model
f013_car_model_classification_code
f013_main_group_code
f013_sub_group_code
f013_fig_illust_disp_no
f013_subgrp_parts_list_dom_content

←
←
←
←
←
←

DOMファイル名から車両モデル「!FS_CAR_MODEL!」
DOMファイル名から類別コード「!FS_CAR_MODEL_CLSSFN!」
DOMファイル名からイングループコード「!FS_MAINGRP_CD!」
DOMファイル名からサブグループコード「!FS_SUBGRP_CD!」
DOMファイル名からイラスト表示順番「!ILLUST_DISP_NO!」
DOMファイルの中身

※Inputスキーマレイアウトが上記定義内容と異なる場合の対応：
  ・項目長の変更

元データの長さチェックをしなくて、呼出し側のコンバート処理にて実施する。プラグイン側に特に何もする必要なし

  ・項目データ型の変更

元データの型チェックをしなくて（object 型として扱うため）、呼出し側のコンバート処理にて実施する。プラグイン側に特に何もする必要なし

  ・新規項目の場合、

上記にない項目については、このプラグインで値をセットしない場合、Inputスキーマで定義されたタイプに応じた初期値が設定されます。
別の初期値が必要な場合は、このプラグインのソースコードを変更する必要があります。

27

f013_xxxx_aaa

←

項目のタイプに応じた初期値を設定
※詳細は、ルールブックのシート「4)データの転記」内の「4　スキーマYAML定義におけるデータ型別初期値」を参照。

2.1.3 エラーデータの処理

レコードのエラーは、エラーハンドリング設定に従って対応されます。

エラーハンドリングモード一覧
エラーハンドリング

resume

skip

terminate

2.2 解析結果の返却

処理方法
エラーレコードをスキップし、次のレコードから処理を続行します。（ExitCode：124）
エラーメッセージを出力し
現在ファイルをスキップします。（ExitCode：124）
エラーメッセージを出力し
エラーメッセージを出力し、全処理を終了します。（ExitCode：255）

LineageIDに対応する入力スキーマレイアウトに従い、DataRow形式の解析結果データをコールバック方式（onDataRow）で呼び出し元に逐次返却します。

プロセスログ

正常件数：{normalCount}
異常件数：{errorCount}

3. 後処理段階 (After)

処理結果の集計およびリソース解放を行い、最終的な終了コード（ExitCode）とメッセージ情報を返却する。

プロセスログ

PROCESS タイプ： 後処理(Afterメソッド) 実行

3.1 処理完了時に、実行結果ログを出力する。

メッセージ:

> 正常完了

INFO タイプ： 「サブグループ別部品情報リストDOMファイルレコード生成」が正常完了しました。

> 異常終了

ERROR タイプ： 「サブグループ別部品情報リストDOMファイルレコード生成」が異常終了しました。

3.2 ExitCodeおよびメッセージ情報の返却

＞　正常終了の場合、ExitCode=0 でリターン、jsonMessageは空です。

7
7
7

7
7
7
7
7
7
7
7

7

＞　異常発生の場合、最後のエラーに対する ExitCode とエラー情報を返却する

7





================================================================================
ドキュメント: プログラム基本設計書_B145_累積作成_サブグループ別部品情報リストDOMファイルレコード生成_処理詳細_V8.pdf (PDF 2)
ファイル名: プログラム基本設計書_B145_累積作成_サブグループ別部品情報リストDOMファイルレコード生成_処理詳細_V8.pdf
================================================================================

3-1.処理詳細説明(全体)

システム名 f013カタログ部品データ作成
業務機能名 累積作成ツール

プログラムID f013-subgrp-parts-list-dom-record-gen プログラム名称 サブグループ別部品情報リストDOMファイルレコード生成

システムID
バージョン
プロジェクトNo

作成日
更新日

12170130-00

2025/1/8
2025/10/19
区分

作成者
更新者

3H.尚坤
3H.尚坤

専用

詳細内容

・解析プラグイン定義

振分モジュールでは、JSON形式の引数をもとに必要な情報を抽出し、部品一覧DOMファイルを読み込みます。

各プラグインは、以下の3段階処理（Before／Main／After）を通じてデータ解析を実施する。

前処理段階 (Before)
本処理段階 (Main)
後処理段階 (After)

実行環境の初期化、入力パラメータ（JSON）の解析、指定ファイルの存在チェック等を行う。
部品一覧DOMファイルを読み込み、解析結果をレコード単位でコールバック関数へ返却する。
処理結果の集計およびリソース解放を行い、最終的な終了コード（ExitCode）とメッセージ情報を返却する。

・API定義

Public Before(string pluginParamJson)

パラメータ：

pluginParamJson

戻り値：

プラグイン実行に必要な情報を格納したJSON文字列。
※詳細レイアウトは「プログラム基本設計書_プラグイン振分モジュール_解析加工IF定義」を参照。

チェック結果

ExitCode およびメッセージ情報（msgId, msg）を返却。

Public Main(Action<DataRow> onDataRow)

レコードを逐次返却する用コールバック
※読み取ったレコードを一つずつ返却するコールバック

パラメータ：

onDataRow

戻り値：
なし

Public After()
戻り値：

＞　正常終了の場合、 ExitCode=0 を返却する
＞　異常発生の場合、最後のエラーに対する ExitCode とエラー情報を返却する

・処理詳細

1. 前処理段階 (Before)

実行環境の初期化、入力パラメータ（JSON）の解析、指定ファイルの存在チェック等を行う。

1.1 起動ログ情報の出力

プラグインの実行開始ログを出力する

出力内容
msgId
CI0001_AppStarted

メッセージテンプレート
「{0}」を開始します...

説明
0: 「サブグループ別部品情報リストDOMファイルレコード生成

詳細は LogUtilityのWrite(string msgId, List<string> paramList,Exception? exception = null) を参照する。

1.2 パラメータの解析

パラメータ pluginParamJson のJSON形式文字列から、使用する情報を解析します。

1.3 リネージ設定情報チェック

1.3.1  「リソース管理」テーブルに、当リネージが使ってるリソースの設定情報チェック

必須項目の設定ありかをチェックして、

文字コード（code_page）が未設定の場合は、

エラーログを出力する（ExitCode：255）

出力内容
msgId

メッセージテンプレート

CE0020_MissingRequir
edItemInSchema

当リネージID「{0}」の「リソース管理テーブル」にて、指定されたInputスキーマYamlファイ
ル:「{1}」に、必須項目「{2}」がないです。

詳細は LogUtilityのWrite(string msgId, List<string> paramList,Exception? exception = null)を参照する。

1.3.2  引数に指定のInputスキーマYamlに必須項目のチェック

指定された Input スキーマファイルに対して、柔軟に対応できるように、最小限の妥当性チェックだけを実施します。
LineageId をもとに転記仕様 YAML（transformYamlInfoDic）から該当のInputスキーマファイルを取得します。
必要な項目IDが含まれているかを確認します。

説明
0：現在処理のリネージID
1：スキーマファイルの名称
2：文字コード（code_page）

改訂No. 削

7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7
7

7
7

7
7
7
7
7
7
7

7
7
7
7

7
7
7

7

7
7

・チェック対象は、必須項目である「項目ID」(item_id) の存在確認に限定します。
＞　Inputスキーマファイルに、プラグインで定義された必須項目 ID が存在しない場合、

エラーログを出力する（ExitCode：253）

出力内容
msgId

メッセージテンプレート

CE0020_MissingRequir
edItemInSchema

当リネージID「{0}」の「リソース管理テーブル」にて、指定されたInputスキーマYamlファイ
ル:「{1}」に、必須項目「{2}」がないです。

説明
0：現在処理のリネージID
1：スキーマファイルの名称
2：項目ID

詳細は LogUtilityのWrite(string msgId, List<string> paramList,Exception? exception = null)を参照する。

必須項目一覧（本プラグインで定義される項目）。

項目№ 項目ID
1
2
3
4
5
6

f013_car_model
f013_car_model_classification_code
f013_main_group_code
f013_sub_group_code
f013_fig_illust_disp_no
f013_subgrp_parts_list_dom_content

項目名
f013・車両モデル
f013・類別コード
f013・メイングループ
f013・サブグループコード
f013・イラスト表示順番
f013・サブグループ別部品情報リストDOMファイル情報

・それ以外の項目（例：項目名、項目順、型、項目長など）については、個別の検証は行いません。

1.4 入力ファイルチェック

1.4.1  入力ファイル名が命名規則に従っているかのチェック
＞　入力ファイル名が命名規則に従っていない場合：

エラーログを出力する（ExitCode：244）

出力内容
msgId

CE0021_DataFileNamin
gRuleMismatch

メッセージテンプレート

説明

対象データファイル「{0}」は、当リネージの命名規則「{1}」に適合しません。

0：入力ファイルフルパス
1：リソース管理テーブル定義の名称ルール(repository+filenamerule)

詳細は LogUtilityのWrite(string msgId, List<string> paramList,Exception? exception = null)を参照する。

1.4.2  入力ファイル命名規則に必須のマクロ変数が含まれているかのチェック
＞　入力ファイル命名規則に必須マクロ変数が定義されていない場合：

エラーログを出力する（ExitCode：253）

出力内容
msgId

メッセージテンプレート

CE0023_MissingRequir
edMacroVariable

当リネージID「{0}」の「リソース管理」テーブルにて、指定された入力ファイル命名規則「{1}
」に必須マクロ変数「{2}」がないです。

詳細は LogUtilityのWrite(string msgId, List<string> paramList,Exception? exception = null)を参照する。

説明

0：現在処理のリネージID
1：入力ファイルの名称ルール
2：必須マクロ変数の名称

1.4.3 入力ファイルの存在チェック

＞　入力ファイルが存在しない場合：

エラーログを出力する（ExitCode：245）

出力内容
msgId

CE0022_DataFileNotFo
und

メッセージテンプレート

説明

対象データファイル「{0}」が見つかりません。

0：入力ファイルのフルパス

詳細は LogUtilityのWrite(string msgId, List<string> paramList,Exception? exception = null)を参照する。

1.4.4 上記のチェック異常、処理対象のDOMファイルサイズは0バイトのチェック

＞ 入力データとしてDOMファイルのサイズを確認し、0 バイトの場合は破損ファイルと見なして処理を中断、

エラーログを出力する（ExitCode：243）

出力内容
msgId
CE0024_DataFileZeroB
ytes

メッセージテンプレート

説明

対象データファイル「{0}」が0バイトで、累積処理を実行できません。

0：入力ファイルのフルパス

詳細は LogUtilityのWrite(string msgId, List<string> paramList,Exception? exception = null)を参照する。

7
7
7

7

7
7

7
7
7

7

7
7

7
7
7

7

7
7

7
7
7

7

7
7

7
7
7

7

7
7

2. 本処理段階 (Main)

部品一覧DOMファイルを読み込み、解析結果をレコード単位でコールバック関数へ返却する。

2.1 DOMファイルの読み取りおよびInputスキーマ構造データの構築

2.1.1 DOMファイルの中身を読み取って、

「リソース管理」テーブルにて、指定文字コード（code_page）に基づいて DOM ファイルの中身を読み取ります。

※BOM 自動処理についてUTF 系文字コードの BOM（Byte Order Mark）は、使用する StreamReader によって自動的に処理されます。
そのため、正しく文字コード（code_page）を指定すれば、BOM の有無にかかわらず正常にテキストを解析できます。

2.1.2 指定列の値設定

DOMファイルのファイル名から、指定のマクロ変数で車の情報を取って、指定スキーマレイアウトにセットします。

・下記項目の値を固定値に設定します
f013_car_model
f013_car_model_classification_code
f013_main_group_code
f013_sub_group_code
f013_fig_illust_disp_no
f013_subgrp_parts_list_dom_content

1
2
3
4
5
6

←
←
←
←
←
←

DOMファイル名から車両モデル「!FS_CAR_MODEL!」
DOMファイル名から類別コード「!FS_CAR_MODEL_CLSSFN!」
DOMファイル名からイングループコード「!FS_MAINGRP_CD!」
DOMファイル名からサブグループコード「!FS_SUBGRP_CD!」
DOMファイル名からイラスト表示順番「!ILLUST_DISP_NO!」
DOMファイルの中身

※Inputスキーマレイアウトが上記定義内容と異なる場合の対応：
  ・項目長の変更

元データの長さチェックをしなくて、呼出し側のコンバート処理にて実施する。プラグイン側に特に何もする必要なし

  ・項目データ型の変更

元データの型チェックをしなくて（object 型として扱うため）、呼出し側のコンバート処理にて実施する。プラグイン側に特に何もする必要なし

  ・新規項目の場合、

上記にない項目については、このプラグインで値をセットしない場合、Inputスキーマで定義されたタイプに応じた初期値が設定されます。
別の初期値が必要な場合は、このプラグインのソースコードを変更する必要があります。

27

f013_xxxx_aaa

←

項目のタイプに応じた初期値を設定
※詳細は、ルールブックのシート「4)データの転記」内の「4　スキーマYAML定義におけるデータ型別初期値」を参照。

2.1.3 エラーデータの処理

レコードのエラーは、エラーハンドリング設定に従って対応されます。

エラーハンドリングモード一覧
エラーハンドリング

resume

skip

terminate

2.2 解析結果の返却

処理方法
エラーレコードをスキップし、次のレコードから処理を続行します。（ExitCode：124）
エラーメッセージを出力し
現在ファイルをスキップします。（ExitCode：124）
エラーメッセージを出力し
エラーメッセージを出力し、全処理を終了します。（ExitCode：255）

LineageIDに対応する入力スキーマレイアウトに従い、DataRow形式の解析結果データをコールバック方式（onDataRow）で呼び出し元に逐次返却します。

3. 後処理段階 (After)

処理結果の集計およびリソース解放を行い、最終的な終了コード（ExitCode）とメッセージ情報を返却する。

3.1 処理完了時に、実行結果ログを出力する。

出力内容
区分

msgId

メッセージテンプレート

正常完了

CI0006_AppSucces
s

「{0}」が正常完了しました。

異常終了 CI0007_AppFailure 「{0}」が異常終了しました。エラー内容: {1}

詳細は LogUtilityのWrite(string msgId, List<string> paramList,Exception? exception = null) を参照する。

3.2 ExitCodeおよびメッセージ情報の返却

＞　正常終了の場合、 ExitCode=0 を返却する
＞　異常発生の場合、最後のエラーに対する ExitCode とエラー情報を返却する

説明

0: サブグループ別部品情報リストPDFファイルレコード生成

0: サブグループ別部品情報リストPDFファイルレコード生成
1: 例外メッセージ（Exception.Message）

7
7

7
7
7
7
7
7
7

7

7

7
7

7
7



